<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> [paper-review] Poisson Reconstruction | Joel Lee </title> <meta name="author" content="Joel Lee"> <meta name="description" content="paper review about prs"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://joonhyung-lee.github.io//blog/2023/prs/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?bf50d6d9dd867d3e0f3b0add94449649"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Joel Lee </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">miscellaneous </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/repositories/">repositories</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/teaching/">teaching</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/gallery/">gallery</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">[paper-review] Poisson Reconstruction</h1> <p class="post-meta"> November 02, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/computer-vision"> <i class="fa-solid fa-hashtag fa-sm"></i> Computer Vision</a>   <a href="/blog/tag/2006"> <i class="fa-solid fa-hashtag fa-sm"></i> 2006</a>     ·   <a href="/blog/category/paper-review"> <i class="fa-solid fa-tag fa-sm"></i> paper-review</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>Eurographics Symposium on Geometry Processing 2006. [<a href="https://hhoppe.com/poissonrecon.pdf" rel="external nofollow noopener" target="_blank">Paper</a>]</p> <p>Michael Kazhdan1<sup>1</sup>, Matthew Bolitho<sup>1</sup> and Hugues Hoppe<sup>2</sup></p> <p><sup>1</sup>Johns Hopkins University, Baltimore MD, USA, <sup>2</sup>Microsoft Research, Redmond WA, USA</p> <p>2006</p> </blockquote> <h2 id="한-문장-요약">한 문장 요약</h2> <p>요약: Surface reconstruction을 Poisson problem으로 해석해서 수행하자.</p> <h3 id="0-reconstruction">0. Reconstruction</h3> <p>이번에 연구 내용으로 수행했던 내용 중 <code class="language-plaintext highlighter-rouge">Real-to-Sim</code> 파트가 있었다. 이는 실제 환경의 3D asset의 정보를 <code class="language-plaintext highlighter-rouge">미리 정의되어 있는</code> Asset pool에서 그대로 MuJoCo simulator로 가져오는 그러한 내용이었다. 이 부분을 구현하면서 많은 아쉬움이 있었다. 우선 3D mesh가 이미 정의되어 있어야 한다는 매우 치명적인 한계가 있었다. 그리고 대부분의 Object shape이 cylinder, sphere, flat한 형태였기에 Orientation을 고려할 수 있는 방법이 없었다. 그러던 와중, 최근 각광받느 NeRF 알고리즘 이전에 3D scene reconstruction 연구에선 어떠한 것이 있었는지 공부하고자 글을 작성한다.</p> <h3 id="1-introduction">1. Introduction</h3> <p>논문은 이와 같은 문장으로 시작한다.</p> <blockquote> <p>We show that surface reconstruction from oriented points can be cast as a spatial Poisson problem. This Poisson formulation considers all the points at once, without resorting to heuristic spatial partitioning or blending, and is therefore highly resilient to data noise.</p> </blockquote> <p>우선, 해당 방법론의 <strong>입/출력</strong> 부터 정의하자면 아래와 같다.</p> <ul> <li>Input : <strong>Point cloud with normal</strong> (이하 oriented points, sample points, 혹은 그냥 points)</li> <li>Output : <strong>Closed Surface</strong> (안과 밖이 명확히 구분 되는 surface. 이하 surface)</li> </ul> <p>우리가 reconstruct 하고자 하는 surface를 다음과 같은 function \(\mathcal{X}\) 으로 생각해볼 수 있다:</p> \[\begin{equation} \mathcal{X}(x,y,z) \end{equation}\] <ul> <li>점 \((x,y,z)\) 가 surface 내부의 점이면 <strong>1</strong>, 외부의 점이면 <strong>0</strong>.</li> </ul> <p>이를 <strong>indication function</strong>이라 하는데, 이 function \(\mathcal{X}(x,y,z)\) 의 공간 상의 변화율(기울기)인 gradient \(\nabla \mathcal{X}\) 를 구하면, <strong>0</strong>에서 <strong>1</strong>로 바뀌는 순간, 즉 surface 상의 점들에서 <strong>0</strong>이 아닌 기울기 벡터를 가지게 될 것이다.</p> <p>기본적으로 이 기울기 vector field는 <strong>surface에서 물체 내부로 향하는 normal vector</strong>랑 같기 때문에, <strong>point cloud with normal</strong>은 기울기 벡터 필드로부터 특정 점들에서의 기울기를 sample로 가져온 것이라 볼 수 있다.</p> <p>즉, 주어진 normal vector를 가진 point set \(\mathrm{V}\)와 가장 유사한 \(\nabla \mathcal{X}\)를 찾아서 \(\nabla \mathcal{X}\) 가 <strong>0</strong>이 아닌 부분들을 추출한다면 surface를 얻을 수 있다는 접근 방식이다.</p> \[\begin{equation} \min_{\mathcal{X}} \vert\vert \nabla \mathcal{X} - \vec{V} \vert\vert \end{equation}\] <p>위 objective를 만족하는 best approximates a vector field \(\vec{V}\) 를 구하기 위해 gradient \(\nabla\) 를 취하면 divergence \(\Delta\) 로 표현되며, 이제 일반적인 Poisson problem으로 치환이 가능하게 된다.</p> \[\begin{equation} \Delta \mathcal{X} = \nabla \cdot \nabla ~ \mathcal{X} = \nabla \cdot \vec{V} \end{equation}\] <blockquote> <p>Poisson problem: compute the scalar function \(\mathcal{X}\) whose Laplacian (divergence of gradient) equals the divergence of the vector field. 이렇게 \(V\)로부터 가장 유사한 \(\nabla \mathcal{X}\)를 찾을 때, 다음과 같은 미분 방정식을 세워서 풀게 된다: \(\Delta \mathcal{X} = \nabla \cdot V\) 이 방정식을 푸는 것을 Poisson problem이라 부르며, 이러한 미분 방정식으로 수행하니 Possion Reconstruction이라고 한다.</p> </blockquote> <div align="center"> <img src="/assets/img/prs/prs-overview.png" width="100%"> <p>Fig. 1: Intuitive illustration of Poisson reconstruction in 2D.</p> </div> <p>이렇게 Poisson problem으로 치환하게 되면 아래의 이점을 갖는다고 한다.</p> <ul> <li>기존의 Implicit surface fitting method는 local approx. 이었으며, 부수적인 엔지니어링이 필요했다. <blockquote> <p>Many implicit surface fitting methods segment the data into regions for local fitting, and further combine these local approximations using blending functions (i.e., RBF approach).</p> </blockquote> <ul> <li> <strong>Poisson reconstruction</strong>은 Global solution을 도출하게 되므로, 이러한 고민을 없애주게 되며 그 결과 또한 smooth surface로 표현된다고 한다.</li> </ul> </li> <li>또, 기존 Implicit fitting 방법론들은 오직 sampled point (i.e., oriented points) 부근에서만 수행된다는 단점이 있다. <ul> <li> <strong>Poisson reconstruction</strong>은 Global하게 이루어지므로 이 또한 해결된다고 표현한다.</li> </ul> </li> </ul> <h3 id="approach">Approach</h3> <div align="center"> <img src="/assets/img/prs/prs-armadillo.png" width="80%"> <p>Fig. 2: Overall procedure about Poisson Surface Reconstruction.</p> </div> <ul> <li>\(S\): Input data, set of sampled \(s \in S\) <ul> <li>each consisting of a <strong>point</strong> \(s.p\) and an <strong>inward-facing normal</strong> \(s.\vec{N}\)</li> </ul> </li> <li>\(M\): Unknown surface model, assumed to \(S\) lies on or near the surface \(\partial M\)</li> </ul> <h4 id="defining-the-gradient-field">Defining the gradient field</h4> <p><strong>목적은 Indicator function을 잘 근사시키는 것이다.</strong> 저자는 이를 위해 Gradient Field를 정의하며 시작한다. Indicator function은 \(\{ 0,1 \}\)로 이루어진 piecewise constant function이다. 이에 대한 gradient field를 구하게 되면 <strong>표면 부근에 대하여 Unbounded value</strong>가 포함되어 있을 것이다. 이를 방지하고자, 저자는 smoothing filter를 고려한 gradient field with a smoothed function Lemma를 제시한다. 이는 <strong>smoothed indicator function</strong>과 <strong>surface normal field에</strong> 대한 관계를 표현한 수식이다.</p> <blockquote> <p>Lemma: Given a solid \(M\) with boundary \(\partial M\), let \(\mathbf{\mathcal{X}_{M}}\) denote the <strong>indicator function</strong> of \(M\), \(\vec{N}_{\partial M} (p)\) be the <strong>inward surface normal</strong> at \(p \in \nabla{M},~ \tilde{F}(q)\) be a smoothing filter, and \(\tilde{F}_{p} (q) = \tilde{F}(q-p)\) its translation to the point \(p\). <strong>The gradient of the smoothed indicator function is equal to the vector field obtained by smoothing the surface normal field:</strong></p> \[\begin{equation} \nabla \left( \mathcal{X}_{M} ~ \ast ~ \tilde{F} \right) \left( q_{0} \right) = \int_{\partial M} \tilde{F}_{p} \left( q_{0} \right) \vec{N}_{\partial M} \left( p \right) dp \end{equation}\] </blockquote> <h4 id="approximating-the-gradient-field">Approximating the gradient field.</h4> <p>입력으로 들어온 oriented point에 대한 integral with discrete summation을 통해 Surface approx.를 수행하게 된다. 구체적으로, 입력 좌표 집합에 대한 여러 patch로 분리하여 (discretize), poisson equation을 세우는 것이다.</p> \[\begin{equation} \begin{align} \nabla (\mathcal{X}_{M}~\ast~\tilde{F}) (q) &amp;= \sum_{s \in S} \int_{\mathcal{P}_{s}} \tilde{F}_{p} (q) \vec{N}_{\partial M} (p) dP \\ &amp;\approx \sum_{s \in S} \vert \mathcal{P}_{s} \vert \tilde{F}_{s.p} (q) s.\vec{N} \equiv \vec{V}(q) \end{align} \end{equation}\] <ul> <li>\(\mathcal{P}_{S} \subset \partial M\) : Distinct patches</li> <li>\(\tilde{F}(p)\): smoothing filter</li> </ul> <p>저자가 말하길, Filter를 설정하는 과정에서 고려할 점이 두 가지가 있다고 한다.</p> <ol> <li>It should be sufficiently narrow so that we do not over-smooth the data</li> <li>It should be wide enough so that the integral over \(\mathcal{P}_{S}\) is well approximated by the value at \(s.p\) scaled by the patch area.</li> </ol> <p>(저자는 위 조건을 만족하는 괜찮은 Filter는 Gaussian으로 사용하는 것을 추천해주었다.)</p> <h4 id="solving-the-poisson-problem">Solving the Poisson problem</h4> <p>우리가 정의한 Vector field에서 indicator function을 풀어내기 위한 정의가 모두 이루어 졌으며, 이에 대한 exact solution은 일반적으로 항상 존재하지 않는다. (not integrable 하므로, 즉 not curl-free 이다.) 그리하여 아래의 수식에 대해 Least-Square 방식으로 해를 근사시켜 해를 구한다.</p> \[\begin{equation} \Delta \mathcal{X} = \nabla \cdot \vec{V} \end{equation}\] <h3 id="implementation">Implementation</h3> <p>우리가 구하고자 하는 indicator function은 기본적으로 continuous function(연속 함수)이다. 따라서 특정 point에서의 normal값만을 가진 input Oriented points들을 3d 공간 상의 연속 함수로 변환시키고 난 뒤에, 컴퓨터 상에서 좀더 효율적으로 계산하기 위해 discretize(이산화) 해서 Poisson equation을 세워야한다.</p> <p>우선은 Input으로 들어온 sample point들을 octree 구조에 배치하고, 각 octree의 node마다 그 안의 점들의 normal vector들의 weighted average를 구하여, 그 node의 normal vector로 삼는다. 이를 Point Rasterization이라고 한다.</p> <p>이때 Octree는 무조건 정해진 depth의 node로 되어 있는 것이 아니라, sampling density에 따라서 점이 많은 곳은 depth가 높고, 점이 적은 곳은 depth가 낮은 octree를 사용하는 adaptive octree이다. Octree의 node o마다 어떤 function Fo를 associate시켜서, 이 Fo들의 조합으로 전체 vector field V를 표현하고, Poisson equation을 컴퓨터 상에서 풀 수 있는 matrix representation으로 세우고, 최종적으로 풀어서 얻은 indicator function도 이 Fo로 표현되게 한다.</p> <p>세워진 Poisson equation은 대략적으로 다음과 같은 과정으로 풀이가 된다. 주어진 octree의 depth D에 대해, Poisson solver는 낮은 depth인 0부터 D까지 한단계씩 높이면서, 낮은 depth에서 solution을 찾아 만족시킨 contraint들은 제외시키고 다음 depth에서 조정된 constraint에 맞춰 풀이를 진행한다. 이런 방식을 Cascadic Solver라고 부른다.</p> <p>현재 쓰이고 있는 Screened Poisson Reconstruction은 Poisson equation을 (∆ - a I)χ = ∇·V 의 형태로 약간 수정한 것인데, 여기서 a값은 기존 Poisson equation의 솔루션 대로 나온 indicator function의 gradient를 중시할 지, 아니면 input으로 넣은 Oriented point들의 배치를 좀더 중시할 지를 따지는 weight값이다. 풀이를 통해 얻은 indicator function의 gradient로부터 <a href="https://en.wikipedia.org/wiki/Marching_cubes" rel="external nofollow noopener" target="_blank">marching cubes</a> 알고리즘을 통해 surface를 represent 한다.</p> <h3 id="experiments">Experiments</h3> <p>Poisson Reconstruction 실행시 결과에 영향을 끼치는 다양한 파라미터가 있으나, 가장 결과물에 영향이 큰 것은 다음 세 가지 정도로 볼 수 있다.</p> <ul> <li>Depth / Weight / Sample per Node</li> </ul> <div align="center"> <img src="/assets/img/prs/prs-dragon.png" width="50%"> <p>Fig. 3: Varying Octree depth value [6, 8, 10]</p> </div> <p>Depth가 높을수록 공간을 분할하는 octree의 node의 개수가 많아지므로 더 세밀하게 나눠진 function들로 표현된 indicator function을 얻게 되므로 결과의 해상도가 올라가게 된다. 단, 점의 밀도가 낮을 경우엔 adaptive octree가 그에 맞춰 낮은 depth의 octree를 사용하기 때문에 이것은 사용할 depth의 최대값이라고 보면 된다.</p> <h3 id="요약">요약</h3> <p>Point cloud를 표현하는 Gradient field를 정의해서 이에 대해 Poisson problem으로 Surface를 표현하는 알고리즘에 대해 공부하였다. 쉽게 비유하자면, Poisson surface reconstruction은은 <strong>Implicit mesh representation</strong> 방법이며, 이는 <strong>매끄러운 천으로 데이터를 감싸는 것</strong>으로 설명할 수 있다. Oriented sample 각각이 갖고 있는 Normal의 Surface에 대해서 새로운 point set \(S'\)을 계산하여 기존의 point set \(S\)와 밀접하게 registration 되도록 하는 것이다.</p> <h5 id="references">References:</h5> <ul> <li><a href="https://hhoppe.com/poissonrecon.pdf" rel="external nofollow noopener" target="_blank">Paper</a></li> <li><a href="https://github.com/hardmaru/pytorch_notebooks/blob/master/mixture_density_networks.ipynb" rel="external nofollow noopener" target="_blank">Code</a></li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/cpl/">[paper-review] Contrastive Prefence Learning: Learning from Human Feedback without RL</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/apriltag-pose-estimation/">[구현] AprilTag Pose Estimation</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/vq/">[study] Vector Quantization</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/rba/">[paper-review] Relative Behavioral Attributes: Filling the Gap between Symbolic Goal Specification and Reward Learning from Human Preferences</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/mdn/">[study] Mixture Density Network</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"joonhyung-lee/joonhyung-lee.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Joel Lee. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>